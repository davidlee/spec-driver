---
id: DR-019
slug: fix-ts-doc-extract-dependency-handling
name: Design Revision - Fix ts-doc-extract dependency handling
created: '2025-11-08'
updated: '2025-11-08'
status: draft
kind: design_revision
aliases: []
owners: []
relations:
- type: implements
  target: DE-019
delta_ref: DE-019
source_context:
- ISSUE-021
code_impacts:
- path: supekku/scripts/lib/sync/adapters/typescript.py
  impact: modified
  scope: dependency_checking
- path: supekku/scripts/lib/core/npm_utils.py
  impact: created
  scope: shared_utilities
- path: supekku/scripts/install.py
  impact: modified
  scope: optional_dependency_setup
verification_alignment:
- type: VT
  target: test_typescript_adapter_handles_missing_ts_doc_extract
  impact: new
- type: VT
  target: test_npm_utils_package_manager_detection
  impact: new
design_decisions:
- Always use --yes flag with npx/pnpm dlx/bunx (non-interactive by definition)
- Check ts-doc-extract availability in TypeScriptAdapter.generate() not _extract_ast()
- Cache availability check per adapter instance to avoid repeated subprocess calls
- Skip TypeScript files gracefully with warning if ts-doc-extract missing
- Support both local (node_modules/.bin/) and global ts-doc-extract installation
- Centralize all npm package manager logic in new npm_utils.py module
open_questions: []
---

# DR-019 – Fix ts-doc-extract dependency handling

## 1. Executive Summary
- **Delta**: [DE-019](./DE-019.md)
- **Status**: draft
- **Owners / Team**: TBD
- **Last Updated**: 2025-11-08
- **Synopsis**: Prevent silent hangs in TypeScript sync by validating ts-doc-extract availability upfront, using `--yes` flags to avoid install prompts, and centralizing npm package manager utilities for reuse across sync, installer, and future doctor command.

## 2. Problem & Constraints

### Current Behaviour

**Silent Hang**: `spec-driver sync` hangs indefinitely when processing TypeScript files if `ts-doc-extract` npm package is not installed (supekku/scripts/lib/sync/adapters/typescript.py:352-415).

**Root Cause**:
- `npx ts-doc-extract` without `--yes` prompts user to install if missing: `"Need to install the following packages: ts-doc-extract"`
- Prompt waits on stdin that never comes (non-interactive context)
- 30s timeout in `subprocess.run()` eventually fires but produces confusing error
- No pre-flight validation, so error occurs mid-sync rather than at start

**Additional Issues**:
- No documentation of ts-doc-extract requirement
- Installer doesn't check for or offer to install the dependency
- Error messages don't provide actionable installation instructions
- Logic for npm/pnpm/bun detection is TypeScript-adapter-specific, not reusable

### Drivers / Inputs
- ISSUE-021: User reported silent hang during sync
- TypeScript contract generation is optional feature requiring optional npm dependency
- Future `doctor` command (ISSUE-022) will need similar dependency checking

### Constraints / Guardrails
- **Non-interactive context**: spec-driver runs in CLI/CI environments; no interactive prompts during sync
- **Graceful degradation**: Missing ts-doc-extract should skip TypeScript with warning, not fail entire sync
- **Package manager agnostic**: Must support npm, pnpm, and bun equivalently
- **Local and global install**: Support both project-local (`node_modules/.bin/`) and global (`npm install -g`) installations
- **DRY principle**: Installation instructions must come from single source of truth, not duplicated strings

### Out of Scope
- Auto-installation of ts-doc-extract during sync (prompting not allowed in non-interactive context)
- Validation of ts-doc-extract version compatibility
- Doctor command implementation (separate delta, ISSUE-022)
- Module granularity improvements (see section 11 for future work)

## 3. Architecture Intent

### Target Outcomes
1. **No silent hangs**: sync command exits or continues gracefully with clear messaging when ts-doc-extract missing
2. **Upfront validation**: Dependency check happens at start of TypeScript processing, not mid-extraction
3. **DRY utilities**: npm package manager detection, availability checking, and install instructions centralized for reuse
4. **Clear user guidance**: Error/warning messages provide actionable installation commands for user's detected package manager

### Guiding Principles
- **Fail fast with context**: Validate dependencies before attempting work; provide specific remediation steps
- **Separation of concerns**: Extract npm-specific utilities to `core/` for reuse by adapters, installer, doctor
- **Graceful degradation**: Optional features (TypeScript sync) degrade gracefully when optional dependencies missing
- **Single source of truth**: Installation instructions generated from package manager detection, not hardcoded

### State Transitions / Lifecycle Impact
None. This delta affects runtime validation, not artifact lifecycle.

## 4. Code Impact Summary

| Path | Current State | Target State |
| --- | --- | --- |
| `supekku/scripts/lib/sync/adapters/typescript.py:309-327` | `_get_npx_command()` returns `["npx"]` / `["pnpm", "dlx"]` / `["bunx"]` without auto-install flags | Returns command builder function; delegates to `npm_utils.get_package_manager_info()` which handles correct syntax per package manager |
| `supekku/scripts/lib/sync/adapters/typescript.py:352-415` | `_extract_ast()` runs npx command directly, hangs on install prompt | Uses cached pm_info with `--yes`, never prompts |
| `supekku/scripts/lib/sync/adapters/typescript.py:476-609` | `generate()` calls `_extract_ast()` without pre-validation | Calls `_ensure_ts_doc_extract_available()` at start; skips all TypeScript files if missing with warning |
| `supekku/scripts/lib/sync/adapters/typescript.py:50-62` | `is_pnpm_available()`, `is_bun_available()` instance methods | Removed; delegated to `npm_utils.is_pnpm_available()` etc. |
| `supekku/scripts/lib/sync/adapters/typescript.py:281-307` | `_detect_package_manager()` static method | Removed; delegated to `npm_utils.detect_package_manager()` |
| `supekku/scripts/lib/core/npm_utils.py` | Does not exist | New module: package manager detection, availability checks, installation instructions |
| `supekku/scripts/install.py:103-221` | `initialize_workspace()` creates directories, copies templates | Adds optional dependency checking: detects TypeScript projects, warns if ts-doc-extract missing |

## 5. Verification Alignment

| Verification | Impact | Notes |
| --- | --- | --- |
| VT-019-001 | new | Unit tests for `npm_utils`: package manager detection from lockfiles, availability checks, install instruction generation |
| VT-019-002 | new | Unit tests for TypeScriptAdapter: handle missing ts-doc-extract gracefully, cache availability check, skip files with warning |
| VT-019-003 | new | Integration test: run sync on TypeScript project without ts-doc-extract, verify warning output and graceful skip |
| VT-019-004 | regression | Existing TypeScriptAdapter tests updated to mock npm_utils functions |

## 6. Supporting Context

### Research
- Analyzed existing package manager detection in `typescript.py:281-307`
- Identified availability check pattern in `go_utils.py:13-23` (`which()` wrapper)
- Found user prompting pattern in `install.py:99-101` (`input()` with Y/n)
- Confirmed auto-install syntax:
  - `npx --yes <package>` - npm's npx with --yes flag
  - `pnpm dlx --package=<package> <package>` - pnpm's dlx requires --package flag
  - `bunx --yes <package>` - bun's bunx with --yes flag

### Related Deltas / Specs
- DE-019 (this delta)
- SPEC-124: supekku/scripts/lib/sync/adapters Specification
- ISSUE-021: Fix ts-doc-extract dependency handling
- ISSUE-022: `spec-driver doctor` command (future work, will reuse npm_utils)

## 7. Design Decisions & Trade-offs

### DEC-019-001: Always use `--yes` flag with npx/pnpm dlx/bunx
**Rationale**: spec-driver runs in non-interactive CLI/CI contexts by definition. Interactive prompts are never appropriate.
**Consequences**:
- Prevents hangs on missing packages
- Simpler code path (no interactive vs non-interactive branches)
- Requires pre-flight validation to avoid silent failures

### DEC-019-002: Check availability in `TypeScriptAdapter.generate()` not `_extract_ast()`
**Rationale**:
- `generate()` is the entry point; checking there validates once before processing any files
- `_extract_ast()` is called per-file; checking there would repeat validation unnecessarily
- Placing check at `generate()` allows graceful skip of entire TypeScript processing with single warning

**Consequences**:
- Clear single point of validation
- Better user experience: one warning instead of repeated errors per file
- Aligns with fail-fast principle

### DEC-019-003: Cache availability check per adapter instance
**Rationale**: Avoid repeated subprocess calls (`npx ts-doc-extract --version`) for each file in a sync run.
**Implementation**: Instance variable `_ts_doc_extract_available: bool | None = None` set on first check.
**Consequences**: Faster sync, reduced subprocess overhead.

### DEC-019-004: Skip TypeScript files gracefully with warning, don't fail sync
**Rationale**:
- TypeScript contract generation is optional feature
- Users may not have TypeScript projects, or may prefer manual contract management
- Failing entire sync for missing optional dependency is poor UX

**Consequences**:
- Better UX for users without TypeScript
- Warning message must be clear and actionable (provide install instructions)
- Sync command succeeds even if some adapters skip files

### DEC-019-005: Support both local and global ts-doc-extract installation
**Rationale**:
- Local install (`npm install --save-dev ts-doc-extract`) is preferred for project reproducibility
- Global install (`npm install -g ts-doc-extract`) is convenient for users
- Both are valid use cases

**Implementation**: Check `node_modules/.bin/ts-doc-extract` before falling back to global PATH lookup.
**Consequences**: More robust detection, supports both workflows.

### DEC-019-006: Centralize npm utilities in `supekku/scripts/lib/core/npm_utils.py`
**Rationale**:
- Package manager detection logic currently duplicated in TypeScriptAdapter
- Future installer and doctor command need same functionality
- Aligns with DRY principle and SoC architecture guideline

**Consequences**:
- Shared utilities reduce duplication
- Installation instructions come from single source (DRY)
- Future features (doctor) can reuse without reimplementation

## 8. Open Questions

None. Design decisions agreed with user.

## 9. Rollout & Operational Notes

### Migration / Backfill
No data migration required. Code changes only.

### Observability / Alerts
Warning message when TypeScript files skipped:
```
⚠ ts-doc-extract not found - skipping TypeScript/JavaScript contract generation

  Install with: npm install -g ts-doc-extract
  Or locally: npm install --save-dev ts-doc-extract

  Then run: spec-driver sync
```

### Recovery / Rollback
No rollback concerns. Changes are additive (new npm_utils module) or improve error handling (TypeScriptAdapter). Worst case: revert commits.

## 10. References & Links

### Implementation Details

**New module: `supekku/scripts/lib/core/npm_utils.py`**

Key functions:
```python
def is_npm_available() -> bool
def is_pnpm_available() -> bool
def is_bun_available() -> bool

def detect_package_manager(path: Path) -> Literal["npm", "pnpm", "bun"]
  """Detect from lockfile: pnpm-lock.yaml > bun.lockb > package-lock.json/yarn.lock."""

@dataclass
class PackageManagerInfo:
  name: Literal["npm", "pnpm", "bun"]
  build_npx_command: Callable[[str], list[str]]  # Function to build command for package
  install_global_command: list[str]  # e.g. ["npm", "install", "-g"]
  install_local_command: list[str]  # e.g. ["npm", "install", "--save-dev"]

def get_package_manager_info(path: Path) -> PackageManagerInfo
  """Get full info for detected package manager.

  Command syntax:
  - npm: npx --yes <package> [args]
  - pnpm: pnpm dlx --package=<package> <package> [args]
  - bun: bunx --yes <package> [args]
  """

def is_npm_package_available(
  package_name: str,
  package_root: Path | None = None
) -> bool
  """Check if npm package available (local node_modules/.bin or global PATH)."""

def get_install_instructions(
  package_name: str,
  pm_info: PackageManagerInfo,
  prefer_local: bool = False
) -> str
  """Generate installation instructions for user's package manager.

  Returns formatted string like:
    Install with: npm install -g ts-doc-extract
    Or locally: npm install --save-dev ts-doc-extract
  """
```

**Updated: `supekku/scripts/lib/sync/adapters/typescript.py`**

Removed methods (delegated to npm_utils):
- `is_pnpm_available()`
- `is_bun_available()`
- `_detect_package_manager()`

Modified methods:
```python
def __init__(self):
  self._ts_doc_extract_available: bool | None = None  # Cache
  self._package_manager_info: PackageManagerInfo | None = None

def generate(self, unit: SourceUnit, *, spec_dir: Path, check: bool = False):
  """Generate contracts for TypeScript/JavaScript module.

  New behavior:
  - Calls _ensure_ts_doc_extract_available() at start
  - If False, prints warning with install instructions and returns early
  - Otherwise proceeds with normal generation
  """

def _ensure_ts_doc_extract_available(self, package_root: Path) -> bool:
  """Check ts-doc-extract availability, cache result, return True if available.

  Implementation:
  - Return cached value if already checked
  - Call npm_utils.is_npm_package_available("ts-doc-extract", package_root)
  - Cache result in self._ts_doc_extract_available
  - If available, cache PackageManagerInfo in self._package_manager_info
  - Return availability status
  """

def _build_npx_command(self, package_name: str, package_root: Path, *args) -> list[str]:
  """Build npx command with correct syntax for detected package manager.

  New implementation:
  - Use cached self._package_manager_info if available
  - Otherwise get_package_manager_info(package_root) and cache it
  - Call pm_info.build_npx_command(package_name) to get base command
  - Append any additional args
  - Returns complete command list ready for subprocess.run()

  Examples:
  - npm: ["npx", "--yes", "ts-doc-extract", ...]
  - pnpm: ["pnpm", "dlx", "--package=ts-doc-extract", "ts-doc-extract", ...]
  - bun: ["bunx", "--yes", "ts-doc-extract", ...]
  """

def _extract_ast(self, file_path: Path, variant: str = "public") -> dict:
  """Extract AST via ts-doc-extract.

  Modified behavior:
  - Assumes _ensure_ts_doc_extract_available() already called by generate()
  - Uses _build_npx_command("ts-doc-extract", package_root, str(file_path), f"--variant={variant}")
  - Command automatically includes correct auto-install syntax for package manager
  - No longer hangs on install prompts
  """
```

**Updated: `supekku/scripts/install.py`**

New function:
```python
def check_optional_dependencies(target_root: Path, auto_yes: bool = False):
  """Check and warn about missing optional dependencies.

  Implementation:
  - Detect if TypeScript files exist (glob for **/*.ts, **/tsconfig.json)
  - If yes, check if ts-doc-extract available
  - If no, print warning with installation instructions from npm_utils
  - Don't prompt to install (installer is interactive, but should inform not force)
  """
```

Call from `initialize_workspace()` after directory structure created.

### Test Coverage

**New: `supekku/scripts/lib/core/npm_utils_test.py`**
- Test package manager detection from lockfiles
- Test availability checks (mock `which()`)
- Test install instruction generation for npm/pnpm/bun
- Test local vs global package detection

**Updated: `supekku/scripts/lib/sync/adapters/typescript_test.py`**
- Mock `npm_utils` functions
- Test graceful skip when ts-doc-extract missing
- Test caching of availability check
- Test warning message output

**New: Integration test**
- Run sync on fixture TypeScript project without ts-doc-extract installed
- Verify warning printed with correct install instructions
- Verify sync succeeds (doesn't fail)
- Verify no TypeScript contracts generated

## 11. Future Work: Module Granularity

### Current Problem

The TypeScript adapter currently creates **one spec per file** for "significant" standalone files (`typescript.py:221-252`), which produces excessive granularity:

- Test case: Medium-sized NextJS project (~1134 files) generated **119 specs**
- Most contracts are tiny (only ~3 have >100 lines)
- Navigation is difficult: deep symlink trees mirroring individual files
- Violates PROD-012.FR-015 (cohesive, right-sized scope)

**Root cause**: `_find_logical_modules()` treats every "significant" file as a module:
```python
# Lines 221-248: Find significant standalone files
for pattern in ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]:
  for file in src_dir.glob(pattern):
    ...
    is_significant = (
      depth <= 1  # Top 2 levels
      or any(part in important_dirs for part in rel_path.parts)
    )
    if is_significant:
      modules.append(file)  # Each file becomes a module!
```

### Python/Go Pattern: Leaf Package Detection

Python adapter uses **leaf packages** - packages that have no child packages (`package_utils.py:17-52`):

```python
def is_leaf_package(path: Path) -> bool:
  """A leaf package:
  1. Contains an __init__.py file (is a Python package)
  2. Has no child directories that are also packages
  """
  if not path.is_dir() or not (path / "__init__.py").exists():
    return False

  # Check for child packages
  for child_dir in path.iterdir():
    if child_dir.is_dir() and (child_dir / "__init__.py").exists():
      return False  # Has child package, not a leaf

  return True
```

**Evaluation against criteria**:
- ✅ **Deterministic**: Based purely on `__init__.py` presence
- ✅ **Stable**: Only changes when package structure changes intentionally
- ✅ **Exhaustive**: Every file is in some package (or orphaned at top level)
- ✅ **Exclusive**: Each file in exactly one leaf package
- ✅ **Cohesive**: Developers already organize code into coherent packages

### Proposed: TypeScript Leaf Module Detection

**TypeScript equivalent**: Find all directories with `index.ts` (or `index.tsx/js/jsx`) that have no child directories with index files.

**Algorithm**:
```python
def is_leaf_module(path: Path) -> bool:
  """A leaf module:
  1. Contains an index file (index.ts/tsx/js/jsx)
  2. Has no child directories that also contain index files
  """
  if not path.is_dir():
    return False

  # Must have index file to be a module boundary
  has_index = any((path / f"index.{ext}").exists()
                  for ext in ["ts", "tsx", "js", "jsx"])
  if not has_index:
    return False

  # Check for child modules
  for child_dir in path.iterdir():
    if child_dir.is_dir():
      has_child_index = any((child_dir / f"index.{ext}").exists()
                            for ext in ["ts", "tsx", "js", "jsx"])
      if has_child_index:
        return False  # Has child module, not a leaf

  return True

def find_all_leaf_modules(root: Path) -> list[Path]:
  """Find all leaf modules under root directory.

  Strategy:
  1. Find all directories containing index files (modules)
  2. Filter to only those with no child modules (leaves)
  3. Return sorted list
  """
  # Find all modules (dirs with index files)
  all_modules = set()
  for ext in ["ts", "tsx", "js", "jsx"]:
    for index_file in root.rglob(f"index.{ext}"):
      all_modules.add(index_file.parent)

  # Filter to leaf modules
  leaf_modules = []
  for module in all_modules:
    has_child = any(
      other != module and other.is_relative_to(module)
      for other in all_modules
    )
    if not has_child:
      leaf_modules.append(module)

  return sorted(leaf_modules)
```

**Handling orphaned files** (no index.ts ancestor):

Option 1: **Top-level directory grouping**
- Files without index.ts ancestor get grouped by their top-level src/ subdirectory
- Example: `src/services/fooService.ts` (no index) → spec for `src/services/`

Option 2: **Per-file specs for orphans only**
- Leaf modules get one spec per module
- Orphaned files get individual specs (but there should be few)

**Recommendation**: Option 1 - top-level directory grouping for orphans. Encourages better structure (add index files) while handling legacy code gracefully.

### Benefits

- **Reduced granularity**: Expected ~10-30 specs instead of ~100+ for typical projects
- **Respects developer intent**: `index.ts` already signals "this is a module boundary"
- **Stable**: Boundaries only change when developers add/remove index files
- **Navigable**: Symlink trees follow logical module structure, not individual files
- **Language-consistent**: Mirrors Python's `__init__.py` pattern

### Migration Strategy

1. Implement `find_all_leaf_modules()` in TypeScript adapter
2. Add fallback for orphaned files (top-level directory grouping)
3. Test on diverse TypeScript/NextJS repos
4. Update existing generated specs (may require manual review/migration)

### Acceptance Criteria

- Medium NextJS project (~1000 files) generates 10-30 specs, not 100+
- Each spec contract >50 lines on average (meaningful content)
- Symlink navigation intuitive (follows module boundaries)
- All files covered (exhaustive)
- No file in multiple specs (exclusive)

**Timeline**: Separate delta post-DE-019 (dependency handling must land first)
