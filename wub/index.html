<!DOCTYPE html>
<head>
  <title>Supekku</title>
  <meta charset="utf-8" />
  <meta content="width=device-width, initial-scale=1" name="viewport" />
  <meta content="light dark" name="color-scheme" />
  <link href="css/pico.min.css" rel="stylesheet" />
  <script defer="" src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
  <link href="https://fonts.googleapis.com" rel="preconnect" />
  <link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect" />
  <link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&amp;family=Momo+Trust+Display&amp;family=Noto+Sans:ital,wght@0,100..900;1,100..900&amp;family=Raleway:ital,wght@0,100..900;1,100..900&amp;display=swap" rel="stylesheet" />
  <link href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.orange.min.css" rel="stylesheet" />
  <link href="styles.css" rel="stylesheet" />
  <script href="behaviour.js"></script>
</head>
<body data-theme="light">
  <header></header>
  <nav>
    <ul>
      <li>
        <a class="contrast" href="#">home</a>
      </li>
      <li>
        <a class="contrast" href="#">about</a>
      </li>
      <li>
        <a class="contrast" href="#">github</a>
      </li>
    </ul>
  </nav>
  <main class="container-fluid">
    <article>
      <section>
        <div>
          <hgroup>
            <h1>
              <mark>spec-driver</mark>
            </h1>
            <p>
              the <mark>specification-driven development</mark> eigentoolkit 
            </p>
          </hgroup>
        </div>
        <p>
          An open, opinionated CLI for spec-driven development.  Notably, it: 
          <ul>
            <li>
              lets markdown files impersonate a relational database
            </li>
            <li>
              scaffolds spec generation (and maintenance!) for Go, Python and TypeScript projects.
            </li>
            <li>
              manages a cohesive set of nouns and verbs. Together, they form an adaptable framework for building at sustainable pace with agents. 
            </li>
          </ul>
        </p>
        <p>
          Stick with the defaults and use everything — or cherry-pick and customise the templates to suit. 
        </p>
        <p>
          Spec-driver is a "variable bureaucracy" framework: work from one line descriptions in a lightweight backlog, up to standalone requirement documents, detailed runsheets, detailed spec revisions, and a full audit trail of verifications tests linked to functional & non-functional requirements. 
        </p>
        <p>
          If you're building something ambitious, the process that got you started will not get you where you're going - and it's a plus if you don't have to declare process bankruptcy three times on the way there. 
        </p>
        <hr />
        <p>
          <mark>spec-driver</mark>came about because I was blown away by <mark><a href="https://github.com/github/spec-kit">spec-kit</a></mark>... until I realised it wasn't actually trying to solve the problem I'd assumed it was. You start with specifications, and it's got a great workflow for taking them from idea to implementation — but there's no support for actually <em>keeping them as a source of truth</em> once you're done. 
        </p>
        <table>
          <thead>
            <tr>
              <th></th>
              <th>
                <a href="https://github.com/github/spec-kit">spec-kit</a>
              </th>
              <th>
                <a href="https://github.com/davidlee/spec-driver">spec-driver</a>
              </th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <th>
                <b>status</b>
              </th>
              <td>
                production - robust, excellent agent commands, multiple maintainers, feature complete
              </td>
              <td>
                beta - expect some rough edges & feature gaps; single maintainer
              </td>
            </tr>
            <tr>
              <th>
                <b>ideal projects</b>
              </th>
              <td>
                smaller projects / microservices (language agnostic)
              </td>
              <td>
                go, python, typescript projects - any size
              </td>
            </tr>
            <tr>
              <th>
                <b>expected prior experience</b>
              </th>
              <td>
                new to spec-driven development
              </td>
              <td>
                prior experience with other tools
              </td>
            </tr>
            <tr>
              <th>
                <b>key strengths</b>
              </th>
              <td>
                documentation; strong community adoption; polished onboarding
              </td>
              <td>
                structured data; evergreen specs; unified CLI for automation
              </td>
            </tr>
            <tr>
              <th>
                <b>weaknesses</b>
              </th>
              <td>
                specifications are disposable; works best with modest codebases; no support for legacy adoption
              </td>
              <td>
                works for me™; rough edges; potential bugs; gaps in documentation & guidance
              </td>
            </tr>
          </tbody>
        </table>
        <figcaption>Comparing spec-kit and spec-driver</figcaption><br />
        <p>
          <b>TL'DR</b>- if you haven't tried spec-kit, maybe start there. If you find yourself wanting more, spec-driver might be for you. 
        </p>
        <hr />
        <div>
          <p>
            <b>The pitch</b>
          </p>
          <blockquote>Stop banging rocks together.</blockquote>
          <ul>
            <li>
              spec-driven development is the only sane way to code with agents
            </li>
            <li>
              so ... you want to write a spec
            </li>
            <li>
              but technical design requires understanding the existing code
            </li>
            <li>
              so ... it's not long until this means a research phase is required for every spec
            </li>
            <li>
              but that only gives you a local understanding of the code explicitly inspected
            </li>
          </ul>
          <p>
            If we're to elevate the role of specifications and build a methodology around them being "executable" by agent developers to drive implementation, isn't it a sign of a critical design flaw if those specifications, and the research that informs them, are only accurate at a point in time? 
          </p>
          <p>
            Put another way: if specs are important enough to name a movement after ... 
          </p>
          <p>
            <mark>why would we accept disposable specs</mark> (and research)  when we could, at no greater cost, ensure the <mark>specs remain a system of truth</mark> about the actual technical design and implementation, and the embodied product requirements? 
          </p>
          <img class="hero" src="./assets/spec-driver.png" />
          <ul>
            <li>
              Maintain <strong>verifiably accurate</strong>, interlinked, <mark>evergreen</mark> specifications for your <em>entire project</em>
            </li>
            <li>
              <mark>Product specs</mark> for user-motivated features, use cases and requirements 
            </li>
            <li>
              <mark>Tech specs</mark> for system architecture and implementation guidance 
            </li>
            <li>
              Deterministically <mark>generate</mark> cheap, concise, accurate documentation for  <em>every line of code</em> within the scope of your spec 
            </li>
            <li>
              These generated <mark>contracts</mark> provide an excellent complement to (and insurance against)  the stochastic nature of research & implementation agents. 
            </li>
            <li>
              They're also an extremely concise, token-effecient reference  for both agents and humans 
            </li>
            <li>
              <mark>Requirements</mark> persist and evolve after initial implementation, with a  rich lifecycle; verification and audit mechanisms 
            </li>
            <li>
              quickly capture desisions, risks, issues, and problem statements / product hypotheses into your <mark>backlog</mark>
            </li>
            <li>
              <mark>Prioritise</mark>, interrogate, and generate implementation plans from your backlog, or absorb them into specs 
            </li>
            <li>
              Evolutionary <mark>governance</mark> of your project with <strong>ADRs</strong> (architecture decision records), <strong>policies</strong> and <strong>standards</strong>
            </li>
            <li>
              Process hooks and tooling support ensure they're considered during design, implementation and verification, and <mark>audits</mark> give you the confidence to change both the code and the rules. 
            </li>
            <li>
              <mark>Markdown + embedded YAML</mark>   makes a surprisingly powerful platform for structured data,  and is highly legible to both human and agent developers 
            </li>
            <li>
              The registry turns markdown files into <mark>relational data</mark>— establishes relationships, quick lookups and validation, and propagates updates 
            </li>
          </ul>
        </div>
        <img src="./assets/simple.svg" />
        <div class="spaced">
          <p>
            Run the <mark>spec-driver sync</mark> command to automatically: 
          </p>
          <ul>
            <li>
              <b>stub out</b> new specs  for unspecified modules 
            </li>
            <li>
              warn (or <pre class="inline">--prune</pre> when specs are "orphaned" by moved or deleted code 
            </li>
            <li>
              <mark>audit</mark>  <b>contract drift:</b> detect when code changes aren't covered by specs 
            </li>
          </ul>
        </div>
        <p>
          <b>Design goals</b>
        </p>
        <ul>
          <li>
            <strong>first-class support</strong> for legacy codebases 
          </li>
          <li>
            keep agents on track, no matter how large the codebase
          </li>
          <li>
            a fast, consistent, unified CLI for everything
          </li>
          <li>
            a great UX for both humans and agents
          </li>
          <li>
            multiple paths to victory: adapt the framework as your needs change, or to the scale and criticality of the task
          </li>
          <li>
            be ready to eat right out of the box
          </li>
        </ul>
      </section>
    </article>
  </main>
  <footer>
    <div>
      David Lee - ⓒ 2025
    </div>
  </footer>
</body>
