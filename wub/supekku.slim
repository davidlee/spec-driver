doctype 5
head
  title Supekku
  meta charset="utf-8"
  meta name="viewport" content="width=device-width, initial-scale=1"
  meta name="color-scheme" content="light dark"
  link rel="stylesheet" href="css/pico.min.css"
  //
  // js
  script [defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"]
  //
  // webfont
  link rel="preconnect" href="https://fonts.googleapis.com"
  link [rel="preconnect" href="https://fonts.gstatic.com" crossorigin]
  //
  link href="https://fonts.googleapis.com/css2?family=Google+Sans+Code:ital,wght@0,300..800;1,300..800&family=Momo+Trust+Display&family=Noto+Sans:ital,wght@0,100..900;1,100..900&family=Raleway:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet"
  //
  // css
  link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.orange.min.css"
  link rel="stylesheet" href="styles.css"
  script href="behaviour.js"
body [data-theme="light"]
  nav
    ul
      li
        a.contrast href="https://davidlee.github.io/spec-driver/" docs
      li
        a.contrast href="https://pypi.org/project/spec-driver/" install
      li
        a.contrast href="https://github.com/davidlee/spec-driver" github
  main.container-fluid
    article
      section
        div
          hgroup
            h1
              mark spec-driver
            p
              |<> the
              mark specification-driven development
              |<> eigentoolkit
        p
          |> An open, opinionated CLI for spec-driven development.  Notably, it:
          ul
            li lets markdown files impersonate a relational database
            li scaffolds spec generation (and maintenance!) for Go, Python and TypeScript projects.
            li
              |> manages a cohesive set of nouns and verbs. Together, they form an adaptable framework
              |> for building at sustainable pace with agents.
        p
          |> Stick with the defaults and use everything — or cherry-pick
          |> and customise the templates to suit.
        p
          |> Spec-driver is a "variable bureaucracy" framework: work from one line descriptions in a lightweight backlog,
          |> up to standalone requirement documents, detailed runsheets, detailed spec revisions, and a
          |> full audit trail of verifications tests linked to functional & non-functional requirements.
        p
          |> If you're building something ambitious, the process that got you started will not get
          |> you where you're going - and it's a plus if you don't have to declare process bankruptcy
          |> three times on the way there.
        hr
        p
          mark spec-driver
          |> came about because I was blown away by
          mark
            a href="https://github.com/github/spec-kit" spec-kit
          |> ... until I realised it wasn't actually trying to solve the problem I'd assumed it was.
          |> You start with specifications, and it's got a great workflow for taking them from idea
          |> to implementation — but there's no support for actually
          em keeping them as a source of truth
          |<> once you're done.

        table
          thead
            tr
              th
              th
                a href="https://github.com/github/spec-kit" spec-kit
              th
                a href="https://github.com/davidlee/spec-driver" spec-driver
          tbody
            tr
              th
                b status
              td production - robust, excellent agent commands, multiple maintainers, feature complete
              td beta - expect some rough edges & feature gaps; single maintainer
            tr
              th
                b ideal projects
              td smaller projects / microservices (language agnostic)
              td go, python, typescript projects - any size
            tr
              th
                b expected prior experience
              td new to spec-driven development
              td prior experience with other tools
            tr
              th
                b key strengths
              td documentation; strong community adoption; polished onboarding
              td structured data; evergreen specs; unified CLI for automation
            tr
              th
                b weaknesses
              td specifications are disposable; works best with modest codebases; no support for legacy adoption
              td works for me™; rough edges; potential bugs; gaps in documentation & guidance
        figcaption fig a) Comparing spec-kit and spec-driver

        br
        p
          b TL'DR
          |> - if you haven't tried spec-kit, maybe start there. If you find yourself wanting more, spec-driver might be for you.
        hr
        // ...
        div
          p
            b The pitch
          blockquote
            | Stop banging rocks together.
          ul
            li spec-driven development is the only sane way to code with agents
            li so ... you want to write a spec
            li but technical design requires understanding the existing code
            li so ... it's not long until this means a research phase is required for every spec
            li but that only gives you a local understanding of the code explicitly inspected
          p
            |> If we're to elevate the role of specifications and build a methodology around them
            |> being "executable" by agent developers to drive implementation, isn't it a sign
            |> of a critical design flaw if those specifications, and the research that informs them,
            |> are only accurate at a point in time?
          p
            |> Put another way: if specs are important enough to name a movement after ...
          p
            mark why would we accept disposable specs
            |<> (and research)
            |<> when we could, at no greater cost, ensure the
            mark specs remain a system of truth
            |<> about the actual technical design and implementation, and the embodied product requirements?
          img.hero src="./assets/spec-driver.png"
          ul
            li
              |<> Maintain
              strong verifiably accurate
              |> , interlinked,
              mark evergreen
              |<> specifications for your
              em entire project
            li
              mark Product specs
              |<> for user-motivated features, use cases and requirements
            li
              mark Tech specs
              |<> for system architecture and implementation guidance

            li
              |<> Deterministically
              mark generate
              |<> cheap, concise, accurate documentation for
              |>
              em every line of code
              |<> within the scope of your spec
            li
              |<> These generated
              mark contracts
              |<> provide an excellent complement to (and insurance against)
              |<> the stochastic nature of research & implementation agents.
            li
              |<> They're also an extremely concise, token-effecient reference
              |<> for both agents and humans
            li
              mark Requirements
              |<> persist and evolve after initial implementation, with a
              |<> rich lifecycle; verification and audit mechanisms
            li
              |> quickly capture desisions, risks, issues, and problem statements / product hypotheses into your
              mark backlog
            li
              mark Prioritise
              |> , interrogate, and generate implementation plans from your backlog, or absorb them into specs
            li
              |> Evolutionary
              mark governance
              |<> of your project with
              strong ADRs
              |<> (architecture decision records),
              strong policies
              |<> and
              strong standards
            li
              |<> Process hooks and tooling support ensure they're considered during design, implementation and verification, and
              mark audits
              |<> give you the confidence to change both the code and the rules.
            li
              mark Markdown + embedded YAML
              |<>
              |<> makes a surprisingly powerful platform for structured data,
              |<> and is highly legible to both human and agent developers
            li
              |> The registry turns markdown files into
              mark relational data
              |> — establishes
              |> relationships, quick lookups and validation,
              |> and propagates updates

        figcaption fig b) a typical workflow: create a delta to bundle some changes; design, plan, implement and verify them; then capture the context with an auto-generated revision, and reflect the changes to specs / requirements
        img src="./assets/simple.svg"
        div.spaced
          p
            |> Run the
            mark spec-driver sync
            |<> command to automatically:
          ul
            li
              b stub out
              |<> new specs
              |<> for unspecified modules
            li
              |> warn (or
              pre.inline --prune
              |<> when specs are "orphaned" by moved or deleted code
            li
              mark audit
              |<>
              b contract drift:
              |<> detect when code changes aren't covered by specs
        hr
        p
          b Design goals

        ul
          li
            strong first-class support
            |<> for legacy codebases
          li keep agents on track, no matter how large the codebase
          li a fast, consistent, unified CLI for everything
          li a great UX for both humans and agents
          li multiple paths to victory: adapt the framework as your needs change, or to the scale and criticality of the task
          li be ready to eat right out of the box
        p
          b Design principles
        ul
          li
            |> Begin with correctness (a
            mark robust conceptual model
            |<> ), and then make it comprehensible; don't start with what's easy and then try to make it work correctly. Compare the trajectories of MySQL (it was fast, they tried to make it correct) and PostgreSQL (it was correct, they made it fast).
          li
            mark self-teaching over instruction
            |<> if we provide tooling which clarifies and reinforces the data model (as with
            pre.inline spec-driver schema show
            |< and the prompts to use it when creating new files), the agent needs far less documentation and behavioural scaffolding, and can often intuit, and even clarify for you how to use the system appropriately.



  footer
    div  David Lee ⓒ  2025



